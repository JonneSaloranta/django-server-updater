name: CI/CD

on:
  push:
    branches:
      - main

permissions:
  contents: write
  packages: write

jobs:
  deploy:
    runs-on: self-hosted
    env:
      REGISTRY: ghcr.io
      IMAGE_NAME: test-server
      STACK_NAME: test-server
      STACK_FILE: docker-compose.yml
      PORTAINER_URL: ${{ secrets.PORTAINER_URL }}
      PORTAINER_API_KEY: ${{ secrets.PORTAINER_API_KEY }}
      SECRET_KEY: ${{ secrets.SECRET_KEY }}
      DEBUG: ${{ secrets.DEBUG }}
      ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
      TIME_ZONE: ${{ secrets.TIME_ZONE }}
      REPO_OWNER: ${{ github.repository_owner }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up environment variables
        id: set-env
        run: |
          # Convert GitHub repository owner to lowercase and set it as an environment variable
          echo "REPO_OWNER=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

          # Ensure IMAGE_NAME is lowercase and set it as an environment variable
          echo "IMAGE_NAME_LOWER=$(echo '${{ env.IMAGE_NAME }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.REPO_OWNER }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.REPO_OWNER }}/${{ env.IMAGE_NAME_LOWER }}:latest

      - name: Deploy with Portainer API
        run: |
          # Ensure jq is installed
          if ! command -v jq &> /dev/null; then
            echo "jq could not be found, installing..."
            sudo apt-get update && sudo apt-get install -y jq
          fi

          # Debug endpoint API response
          curl -s -H "Authorization: Bearer ${{ env.PORTAINER_API_KEY }}" \
              "${{ env.PORTAINER_URL }}/api/endpoints" | tee endpoints.json | jq .

          # Get the endpoint ID
          ENDPOINT_ID=$(cat endpoints.json | jq -r '.[] | .Id')

          if [ -z "${ENDPOINT_ID}" ]; then
            echo "Error: Failed to get the endpoint ID."
            exit 1
          fi

          # Debug stacks API response
          curl -s -H "Authorization: Bearer ${{ env.PORTAINER_API_KEY }}" \
              "${{ env.PORTAINER_URL }}/api/stacks" | tee stacks.json | jq .

          # Check if stack exists
          STACK_ID=$(cat stacks.json | jq -r '.[] | select(.Name=="test-server") | .Id')

          # Prepare the stack file content
          STACK_FILE_CONTENT=$(cat ${{ env.STACK_FILE }} | sed 's/\\/\\\\/g' | sed ':a;N;$!ba;s/\n/\\n/g')

          # Deploy or update the stack
          if [ -z "${STACK_ID}" ]; then
            # Create stack
            RESPONSE=$(curl -s -o response.json -w "%{http_code}" -X POST -H "Authorization: Bearer ${{ env.PORTAINER_API_KEY }}" \
                -H "Content-Type: application/json" \
                --data-binary @<(cat <<EOF
                {
                  "Name": "test-server",
                  "EndpointId": ${ENDPOINT_ID},
                  "SwarmID": "",
                  "StackFileContent": "${STACK_FILE_CONTENT}",
                  "Env": [
                    {
                      "name": "SECRET_KEY",
                      "value": "${{ env.SECRET_KEY }}"
                    },
                    {
                      "name": "DEBUG",
                      "value": "${{ env.DEBUG }}"
                    },
                    {
                      "name": "ALLOWED_HOSTS",
                      "value": "${{ env.ALLOWED_HOSTS }}"
                    },
                    {
                      "name": "TIME_ZONE",
                      "value": "${{ env.TIME_ZONE }}"
                    }
                  ]
                }
              EOF
                ) \
                "${{ env.PORTAINER_URL }}/api/stacks?method=string&endpointId=${ENDPOINT_ID}")

            if [ "${RESPONSE}" -ne 200 ]; then
              echo "Error: Failed to create the stack."
              cat response.json
              exit 1
            fi
          else
            # Update stack
            RESPONSE=$(curl -s -o response.json -w "%{http_code}" -X PUT -H "Authorization: Bearer ${{ env.PORTAINER_API_KEY }}" \
                -H "Content-Type: application/json" \
                --data-binary @<(cat <<EOF
                {
                  "StackFileContent": "${STACK_FILE_CONTENT}",
                  "Env": [
                    {
                      "name": "SECRET_KEY",
                      "value": "${{ env.SECRET_KEY }}"
                    },
                    {
                      "name": "DEBUG",
                      "value": "${{ env.DEBUG }}"
                    },
                    {
                      "name": "ALLOWED_HOSTS",
                      "value": "${{ env.ALLOWED_HOSTS }}"
                    },
                    {
                      "name": "TIME_ZONE",
                      "value": "${{ env.TIME_ZONE }}"
                    }
                  ]
                }
          EOF
                ) \
                "${{ env.PORTAINER_URL }}/api/stacks/${STACK_ID}/update?endpointId=${ENDPOINT_ID}")

            if [ "${RESPONSE}" -ne 200 ]; then
              echo "Error: Failed to update the stack."
              cat response.json
              exit 1
            fi
          fi
        shell: /usr/bin/bash -e {0}
